# Лекція 10: Потоки змін (Change Streams)

Потоки змін (Change Streams) у MongoDB — це API, яке дозволяє в режимі реального часу відстежувати оновлення даних у колекціях або базах даних. Вони дозволяють додаткам підписуватися на події змін (вставка, оновлення, видалення тощо) і реагувати на них миттєво, що особливо корисно для логування та синхронізації даних.

Основи:
* Change Streams доступні тільки в MongoDB, якщо під’єднані до репліка-сету або шардованого кластера.

* Вони працюють на серверному рівні, відстежуючи зміни у будь-якому інтерфейсі, наприклад, навіть якщо дані змінювалися через MongoDB GUI.

* Методи **watch()** застосовуються до колекції, бази даних або навіть на рівні клієнта, щоб почати прослуховування змін.

* Зміни повертаються у вигляді подій із деталями про операцію, час і нові дані.

### Типи подій
При подіях змін повертаються такі основні типи операцій:

* **insert** - вставка нового документа;

* **update** - оновлення існуючого документа;

* **replace** - заміна документа;

* **delete** - видалення документа;

* **invalidate** - подія, що означає припинення дії потоку змін через операцію, яка робить його недійсним, наприклад видалення, перейменування колекції або зміна конфігурації бази (наприклад, видалення бази даних).

## Приклад створення Change Stream


```js
const mongoose = require('mongoose');
const Person = mongoose.model('Person', new mongoose.Schema({ name: String }));

// Підписка на зміни у колекції Person
Person.watch().on('change', change => {
  console.log("Отримано зміни:", change);
});

// Створення нового документа, щоб викликати подію вставки
await Person.create({ name: 'Axl Rose' });
```

У цьому прикладі створено змінну для колекції **Person**, підписуємося на зміни і виводимо їх у консоль. Коли в колекцію додається новий документ, спрацьовує подія insert з детальною інформацією про вставлений документ.

## Формат об'єкта події зміни
Приклад вихідних даних з потоку змін після вставки документа:

```json
{
  "operationType": "insert",
  "fullDocument": {
    "_id": "62408dac6f5c42ff5ee087a2",
    "name": "Axl Rose",
    "__v": 0
  },
  "ns": {
    "db": "test",
    "coll": "people"
  },
  "documentKey": {
    "_id": "62408dac6f5c42ff5ee087a2"
  },
  "clusterTime": "Timestamp({ t: 1648397740, i: 1 })"
}
```

* **operationType** - тип операції;

* **fullDocument** - повний документ після зміни (для вставок і замін);

* **ns** - простір імен бази даних і колекції;

* **documentKey**  - ключ документа (зазвичай _id);

* **clusterTime** - час кластера при зміні.

### Приклад обробки оновлень

```js
Person.watch().on('change', change => {
  if (change.operationType === 'update') {
    console.log(`Документ з _id=${change.documentKey._id} було оновлено`);
  }
});
```

Цей код реагує лише на операції оновлення, виводить ідентифікатор документу та які поля було змінено.

### Фільтрація подій


Change Streams підтримують фільтрацію подій на сервері, що дозволяє підписатися на конкретні типи подій чи документи за допомогою агрегаційних стадій.

Приклад фільтрації лише вставок у певній колекції:

```js
Person.watch([
  { $match: { operationType: "insert" } }
]).on('change', change => {
  console.log("Нова вставка:", change.fullDocument);
});
```


### Використання Change Streams на рівні бази даних

Для відстеження змін у всіх колекціях бази можна викликати **watch()** на об’єкті бази даних.

```js
const db = mongoose.connection.db;

db.watch().on('change', change => {
  console.log("Зміна у базі:", change);
});
```


### Обмеження
* потрібен MongoDB replica set або шардований кластер;

* сповіщення надходять після фіксації змін;

* при підключенні до standalone-сервера **watch()** викличе помилку;

* для локальної розробки можна створити одновузловий replica set (single-node replica set);

* у продакшені рекомендовано використовувати MongoDB Atlas для стабільності роботи change streams.


### Практичне застосування

Change Streams корисні для:

* real-time додатків, що реагують на зміни даних миттєво;

* систем моніторингу;

* синхронізації даних між системами;

* етапів імплементації event-driven архітектур.

Приклад комплексного підключення з обробкою помилок:

```js
const mongoose = require('mongoose');

async function watchChanges() {
  const Person = mongoose.model('Person', new mongoose.Schema({ name: String }));

  try {
    const changeStream = Person.watch();
    changeStream.on('change', (change) => {
      console.log('Отримано зміну:', change);
    });
  } catch (error) {
    console.error("Помилка Change Stream:", error);
  }
}

watchChanges();
```
