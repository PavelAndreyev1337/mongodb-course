# Лекція 7: Транзакції
## Знайомство з транзакціями
Транзакція — це послідовність операцій з базою даних, яку потрібно виконати як єдине ціле. Тобто всі операції в транзакції проходять або всі разом, або жодна — це забезпечує атомарність. Транзакції гарантовано зберігають консистентність бази, навіть якщо щось іде не так (збої, помилки).

Раніше MongoDB не підтримувала транзакції між кількома документами. З появою багатодокументних транзакцій (починаючи з версії 4.0 і далі) MongoDB наблизилась до класичних реляційних СУБД за надійністю операцій. Транзакції доступні тільки у replica sets і шардованих кластерах; у standalone режимі багатодокументні транзакції не підтримуються.

Replica set — це група MongoDB-серверів, які працюють разом, щоб забезпечити відмовостійкість та реплікацію даних. Вони мають один первинний сервер (primary), який обробляє всі операції запису, і кілька вторинних серверів (secondaries), що автоматично дублюють дані з первинного. Якщо первинний сервер виходить з ладу, один із вторинних автоматично стає новим первинним. Це забезпечує цілісність та доступність даних навіть при збоях серверів.​

Шардовані кластери. Шардування — це метод горизонтального масштабування, при якому дані розподіляються по кількох серверах (шардах). Кожен шард зберігає частину всіх даних (на основі ключа шард-ключа). Це дозволяє обробляти великі об’єми даних та багато запитів одночасно, розподіливши навантаження. В такому кластері є компоненти: config server (зберігає метадані) і mongos (міжмодель маршрутизації запитів). Це підвищує масштабованість, продуктивність і резервування.
У MongoDB у standalone режимі (окремий сервер без replica set) транзакції за замовчуванням не підтримуються. Щоб використовувати транзакції, навіть на одному сервері, потрібно включити режим replica set, створивши одновузловий replica set. Для цього:
1. Зупиніть процес MongoDB.
2. У конфігураційному файлі або під час запуску вкажіть параметр для replica set.
Конфігураційний файл MongoDB зазвичай називається mongod.conf або mongod.cfg. На Windows цей файл часто знаходиться в домашній папці установки MongoDB або створюється вручну користувачем, наприклад, у каталозі C:\mongodb\mongod.cfg.
На Linux шляхи можуть бути схожими — /etc/mongod.conf або /usr/local/etc/mongod.conf, залежно від способу установки.
Під час запуску:

`mongod --replSet rs0 --bind_ip localhost`
* mongod — запуск MongoDB сервера.

* --replSet rs0 — активує режим replica set з іменем rs0. Це потрібно для підтримки реплікації, тобто дублювання даних між кількома серверами.

* --bind_ip localhost — прив’язує сервер до IP-адреси localhost (127.0.0.1), тобто MongoDB буде доступний лише з локального комп’ютера.

Або ж додайти в конфіг файл:

```
replication:
  replSetName: rs0
```

3. Запустіть MongoDB з цим параметром.

4. Підключіться до MongoDB shell і ініціалізуйте replica set командою:

```
rs.initiate()
```
Також треба встановити readConcern та writeConcern в { level: "snapshot" } та { w: "majority" } — зчитування буде знімком стану бази на момент початку транзакції; операція вважається успішною, лише коли більшість вузлів репліки підтвердили запис.
Після цього можна використовувати транзакції, навіть якщо у вас лише один сервер у replica set.

```javascript
const client = new MongoClient("mongodb://localhost:27017", {
  writeConcern: { w: 1 },
  readConcern: { level: "local" }
});
```

## Визначення ACID
MongoDB підтримує транзакції з ACID-властивостями:
 - Атомарність (Atomicity): всі операції в середині транзакції завершуються або відміняються разом.
- Узгодженість (Consistency): після транзакції дані залишаються коректними, всі правила і обмеження дотримані.
- Ізольованість (Isolation): операції в одній транзакції приховані від інших до її завершення.
- Довговічність (Durability): після підтвердження транзакції її зміни зберігаються навіть при відмовах.

## Приклади випадків застосування транзакцій
* Фінансові операції: перекази коштів між рахунками, де важливо, щоб списання та зарахування відбулись разом.
* Обробка замовлень: оновлення інформації в кількох колекціях (наприклад, запаси товару і статус замовлення).
* Робота зі складними бізнес-логіками, де дані розподілені по декількох колекціях.

## Основні виклики і обмеження
* Використання транзакцій збільшує затримки, бо система гарантує консистентність і ізоляцію.
* Транзакції краще використовувати там, де критична цілісність даних, а не для простих CRUD.
* Для високо навантажених операцій з багатьма конкурентами варто зважити, чи не краще спростити логіку, уникаючи великих транзакцій.

Чому варто уникати великих транзакцій у високо навантажених системах:
1. Зниження продуктивності (Performance)
Транзакції в MongoDB утримують блокування (локи) на час свого виконання.
Чим довше триває транзакція, тим більше часу інші запити чекають, що веде до затримок і зниження пропускної здатності системи.
2. Високе навантаження на пам’ять
Під час транзакції MongoDB зберігає проміжні зміни в оперативній пам’яті.
Великі транзакції → більше пам’яті → ризик вичерпання ресурсів або скидання транзакції.
3. Ризик конфліктів і відкатів
У конкурентному середовищі кілька транзакцій можуть конфліктувати за одні й ті самі документи.
MongoDB використовує оптимістичну конкуренцію, і при конфлікті може відкотити транзакцію.
Це означає, що ваша транзакція може не завершитися успішно, а доведеться повторити її — ще більше навантаження.
4. Складність супроводу і масштабування
Великі транзакції складніше дебажити, відновлювати у разі помилок або аварій.
Вони можуть стати вузьким місцем при горизонтальному масштабуванні.
## Використання транзакцій
Пригадаймо, що транзакції в MongoDB використовуються для забезпечення цілісності даних при виконанні кількох операцій як однієї логічної одиниці. Ось основні моменти використання транзакцій у MongoDB з прикладами:
1. Створюється сесія:

```javascript
session = db.getMongo().startSession()
```
2. Починається транзакція:
```javascript
session.startTransaction()
```
3. Виконуються операції з вказанням сесії як параметра:
```javascript
javascript
db.collection1.insertOne({"foo": "bar"}, {session: session})
db.collection2.updateOne({"baz": 1}, {$set: {"qux": 2}}, {session: session})
```
4. Підтверджується транзакція
```javascript
session.commitTransaction()
```
5. Завершується сесія
```javascript
session.endSession()
```
6. Також, якщо виникла помилка транзакцію можна скасувати (ролбек)
```javascript
session.abortTransaction()
```
Продемонстровано стандартний спосіб запуску транзакцій у mongo shell або у скриптах з підтримкою MongoDB.
Щодо чекпоінтів (checkpoints), в MongoDB вони не є користувацьким явищем, а працюють на рівні механізму збереження даних, зокрема для двигуна збереження WiredTiger. Ці чекпоінти автоматично створюються системою (приблизно кожні 60-100 секунд) і служать для мінімізації втрати даних у разі аварійного завершення роботи. Вони забезпечують стабільність і відновлення бази даних.
## Налаштування обмежень транзакцій для додатка
У транзакціях MongoDB є дві основні категорії обмежень. Перша відноситься до тимчасових обмежень транзакції, контролю тривалості конкретної транзакції, часу очікування транзакції для отримання блокувань та максимальної тривалості
виконання всіх транзакцій. Друга категорія, зокрема, відноситься до запису в журналі операцій MongoDB та обмежень розміру окремого запису.
Обмеження за часом
Максимальний час виконання транзакції за замовчуванням ня становить одну хвилину або менше. Його можна збільшити шляхом зміни обмеження, керованого параметром transactionLifetimeLimitSeconds на рівні mongod.

Обмеження на розмір журналу операцій MongoDB створить стільки записів у журналі операцій, скільки необхідно для операцій запису в транзакції. Однак кожен запис повинен знаходитися в межах обмежень розміру документа формату BSON 16 МБ.

У MongoDB рівнів ізоляції транзакцій як у класичних традиційних СУБД немає в типовому розумінні. Основний рівень ізоляції транзакцій у MongoDB — це snapshot isolation.
Під час транзакції всі операції бачать «знімок» (snapshot) даних у тому стані, в якому вони були на початку транзакції.

Інші транзакції не бачать проміжні зміни, доки транзакція не буде підтверджена (commit).

Забезпечує ізольованість читання і запису під час виконання транзакції.

Гарантує, що транзакція працює з консистентним станом без «брудних» або неповних даних.

# Приклад використання
1. Створення бази і колекцій
```javascript
// Використовуємо (підключаємось) до бази shopDB (створиться під час першої операції)
use shopDB

// Створюємо колекцію products і додаємо кілька товарів
db.products.insertMany([
  { productId: 1, name: "Ноутбук", stock: 10, price: 1500 },
  { productId: 2, name: "Смартфон", stock: 15, price: 800 },
  { productId: 3, name: "Навушники", stock: 30, price: 150 }
])

// Створюємо колекцію orders (замовлення)
db.orders.insertOne({ orderId: 100, productId: 1, quantity: 1, status: "completed" })
```

2. Використання агрегацій для аналітики,
порахувати загальну вартість замовлень за кожним товаром:

```javascript
db.orders.aggregate([
  {
    $lookup: {
      from: "products",
      localField: "productId",
      foreignField: "productId",
      as: "productDetails"
    }
  },
  { $unwind: "$productDetails" },
  {
    $group: {
      _id: "$productId",
      totalQuantity: { $sum: "$quantity" },
      totalRevenue: { $sum: { $multiply: ["$quantity", "$productDetails.price"] } }
    }
  }
])
```

Цей агрегаційний пайплайн поєднує замовлення з товарами та вираховує загальну кількість і дохід по кожному товару.

3. Демонстрація транзакції у mongosh
```javascript
// Запускаємо сесію та транзакцію
const session = db.getMongo().startSession()
session.startTransaction()

try {
  // Вставка нового замовлення у колекцію orders
  db.orders.insertOne(
    { orderId: 101, productId: 2, quantity: 3, status: "processing" },
    { session }
  )

  // Оновлення кількості товару на складі
  let updateResult = db.products.updateOne(
    { productId: 2, stock: { $gte: 3 } },
    { $inc: { stock: -3 } },
    { session }
  )

  if (updateResult.matchedCount === 0) {
    // Якщо на складі немає потрібної кількості - робимо ролбек
    throw new Error("Недостатньо товару на складі")
  }

  // Підтвердження транзакції
  session.commitTransaction()

  print("Транзакція виконана успішно")
} catch (error) {
  print("Транзакція скасована через помилку: " + error.message)
  session.abortTransaction()
} finally {
  session.endSession()
}
```

У цьому прикладі:
* Додається нове замовлення.
* Оновлюється запас товару у products.
* При нестачі товару транзакція відкочується.

Таким чином, транзакції в MongoDB дають можливість гарантувати надійність і цілісність даних у складних бізнес-логіках, де потрібно зберігати кілька документів у синхронізованому стані.