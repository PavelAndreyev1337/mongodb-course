# Лекція 8: Векторний пошук

MongoDB підтримує векторний пошук (Vector Search), який використовується для збереження та пошуку векторних ембедингів, що особливо важливо для семантичного пошуку і генеративного штучного інтелекту (RAG-систем). Генерація з доповненням через пошук (англ. Retrieval-Augmented Generation, RAG) — це техніка, що поєднує пошук інформації з її генерацією для створення більш точних і контекстуально релевантних відповідей.
Векторний пошук у базах даних — це метод пошуку, який замість простого пошуку за ключовими словами або фільтрами дозволяє шукати об'єкти за схожістю їх векторних подань (ембедингів). Це особливо корисно в задачах семантичного пошуку, наприклад, для пошуку схожих текстів, зображень, музики та інших даних, які представляються у вигляді багатовимірних векторів.
MongoDB такі функції, щоб підтримувати запити по векторних ембедінгах, що робить базу даних потужною для застосувань у сфері штучного інтелекту.
Векторний пошук у MongoDB Community підтримує вектори розмірністю до 8192.


## Як працює векторний пошук у MongoDB
* Дані конвертуються у вектори, наприклад, за допомогою моделей машинного навчання (наприклад, трансформерів).

* Вектори додаються до колекції MongoDB разом з іншими даними.

* Створюється векторний індекс із заданою розмірністю і налаштовується функція подібності (косинусна, евклідова тощо).

* Запити здійснюються через агрегаційний пайплайн із етапом **$vectorSearch**, де запит представлений у вигляді вектора.

* Результатом є документи з найближчими за подібністю.

## Синтаксис створення векторних індексів 
У MongoDB створення векторного індексу відбувається через команду створення індексу з типом "vector" та параметрами конфігурації. Приклад:

```javascript
db.collection.createIndex(
  { vectorField: "vector" },
  {
    "vector": {
      "dimensions": 8192,           // розмірність векторів
      "similarity": "cosine",       // метрика подібності (cosine, euclidean, dotProduct)
      "algorithm": "hnsw",          // алгоритм пошуку (hnsw - Hierarchical Navigable Small Worlds)
      "m": 16,                     // параметр алгоритму HNSW (розгалуження)
      "efConstruction": 200         // параметр побудови графа HNSW
    }
  }
)
```

Основні параметри:

* dimensions — кількість числових елементів у векторі.

* similarity — метрика, за якою обчислюється подібність векторів. Найчастіше використовується косинусна схожість.

* algorithm — алгоритм побудови індекса для пошуку (HNSW найпопулярніший).

* m і efConstruction — параметри, які впливають на швидкість та точність пошуку.

Після створення такого індексу можна виконувати пошук по векторному полю через агрегаційний оператор **$vectorSearch** у запиті.

Hierarchical Navigable Small Worlds (HNSW) — це графовий алгоритм для пошуку найближчих сусідів (approximate nearest neighbor, ANN) у великих наборах даних, особливо у високовимірних векторних просторах.

Пошук найближчих сусідів (Nearest Neighbor Search) — це задача знаходження об’єктів у наборі даних, які є найбільш близькими до заданого запиту за визначеною мірою відстані або схожості (наприклад, евклідова відстань чи косинусна схожість). Іншими словами, це пошук точок, які максимально схожі або найменш віддалені від шуканого об’єкта у багатовимірному просторі.

# Створення індексу для векторного пошуку

MongoDB підтримує індекси для швидкого пошуку найближчих векторів, наприклад:

```js
db.hotels.createIndex(
  { embedding: "knnVector" },
  { metric: "cosine", dimensions: 4 }
)
```
* embedding — поле з векторами;
* metric — метрика подібності (косинусна);
* dimensions — розмірність вектора.

## Створення колекції з векторними ембедингами
Дані для прикладу:

```js
db.documents.insertMany([
  { _id: 1, name: "Документ A", embedding: [0.1, 0.2, 0.3, 0.4] },
  { _id: 2, name: "Документ B", embedding: [0.3, 0.1, 0.5, 0.2] },
  { _id: 3, name: "Документ C", embedding: [0.4, 0.4, 0.2, 0.1] }
])
```

## Індексування векторних даних (vector index)

MongoDB надає можливість створити спеціальний тип індексу для векторного пошуку. Наприклад, створимо індекс для поля "embedding":

```js
db.documents.createIndex(
  { embedding: "2dsphere" }
)
```

В реальних умовах для векторів використовується спеціальний тип індексу, наприклад, **vector** або **knnVector**, залежно від версії MongoDB і драйверів.


## Пошук за найбільш схожим вектором
Запит для пошуку документів, найбільш близьких до заданого вектора:

```js
db.documents.find({
  embedding: {
    $nearest: [0.2, 0.1, 0.4, 0.3],
    $maxDistance: 0.5
  }
})
```

Або з використанням агрегації та оператора $vectorSearch:

```js
db.documents.aggregate([
  {
    $vectorSearch: {
      queryVector: [0.2, 0.1, 0.4, 0.3],
      path: "embedding",
      k: 2
    }
  }
])
```

Припустимо, що найближчі документи за векторною відстанню (косинусна схожість або евклідова відстань) це "Документ A" та "Документ B". Отримаємо такий результат:

```json
[
  { "_id": 1, "name": "Документ A", "score": 0.95 },
  { "_id": 2, "name": "Документ B", "score": 0.89 }
]
```
Для векторного пошуку важливо враховувати тип відстані (косинусна, евклідова тощо). В реальних застосунках база часто комбінується з AI моделями, які створюють ембединг
