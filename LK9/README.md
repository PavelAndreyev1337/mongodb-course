# Лекція 8: Векторний пошук

Векторний пошук в MongoDB Atlas (далі MongoDB) використовується для збереження та пошуку векторних ембедингів, що особливо важливо для семантичного пошуку і генеративного штучного інтелекту (RAG-систем). Генерація з доповненням через пошук (англ. Retrieval-Augmented Generation, RAG) — це техніка, що поєднує пошук інформації з її генерацією для створення більш точних і контекстуально релевантних відповідей.
Векторний пошук у базах даних — це метод пошуку, який замість простого пошуку за ключовими словами або фільтрами дозволяє шукати об'єкти за схожістю їх векторних подань (ембедингів). Це особливо корисно в задачах семантичного пошуку, наприклад, для пошуку схожих текстів, зображень, музики та інших даних, які представляються у вигляді багатовимірних векторів.
Такі функції, дозволяють підтримувати запити по векторних ембедингах, що робить базу даних потужною для застосувань у сфері штучного інтелекту.
Векторний пошук у MongoDB підтримує вектори розмірністю до 1024.

## Як працює векторний пошук у MongoDB
* Дані конвертуються у вектори, наприклад, за допомогою моделей машинного навчання (наприклад, трансформерів).

* Вектори додаються до колекції MongoDB разом з іншими даними.

* Створюється векторний індекс із заданою розмірністю і налаштовується функція подібності (косинусна, евклідова тощо).

* Запити здійснюються через агрегаційний пайплайн із етапом **$vectorSearch**, де запит представлений у вигляді вектора.

* У результаті повертаються документи, які мають найбільшу схожість з шуканим вектором.

## Синтаксис створення векторних індексів 
Щоб створити векторний індекс у MongoDB через конфігураційний файл JSON, потрібно скористатися JSON-форматом, який описує поле з векторами, кількість вимірів та метрику схожості. Нижче наведено приклад такого визначення, актуального для MongoDB Atlas Vector Search:

```js
{
  "fields": [{
    "type": "vector",
    "path": "<field name to index>",
    "numDimensions": <number of dimensions>,
    "similarity": "<euclidean | cosine | dotProduct>"
  }]
}
```

Основні параметри:

* type: вказує що це векторний індекс;

* path: назва поля, в якому зберігаються вектори;

* numDimensions: кількість вимірів вектора;

* similarity: метрика схожості — одна з euclidean, cosine або dotProduct.

Після створення такого індексу можна виконувати пошук по векторному полю через агрегаційний оператор **$vectorSearch** у запиті.

## Створення колекції з векторними ембедингами
Дані для прикладу:

```js
db.documents.insertMany([
  { _id: 1, name: "Документ A", embedding: [0.1, 0.2, 0.3, 0.4] },
  { _id: 2, name: "Документ B", embedding: [0.3, 0.1, 0.5, 0.2] },
  { _id: 3, name: "Документ C", embedding: [0.4, 0.4, 0.2, 0.1] }
])
```

## Створення векторного індекса в MongoDB Atlas.
Спершу відкрити MongoDB Compass і підключитися до вашого Atlas кластера та обрати потрібну базу даних і колекцію. Далі перейти у вкладку «Indexes» у вибраній колекції. Там є можливість створити новий індекс.

Вибрати опцію створення індексу пошуку (Atlas Search Index). Compass надає редактор для створення індексу, де можна використати JSON-конфігурацію для налаштування векторного індексу. У цій конфігурації потрібно вказати, що індекс повинен створюватись для поля, яке містить векторні ембедінги, наприклад, поле "embedding". Вказати тип індексу як "vector", задати кількість вимірів вектора (numDimensions) і тип метрики схожості (наприклад, cosine).

Після заповнення конфігурації потрібно зберегти індекс. MongoDB Compass подасть статус створення індексу, і коли ідентифікатор стане активним, індекс буде готовий до використання для векторного пошуку.

Потім можна виконувати запити з використанням агрегатних операторів $vectorSearch, які шукатимуть найбільш близькі вектори та пов’язані з ними документи.

Процес через Compass є інтуїтивним: вибір колекції, перехід у вкладку індексів, створення нового індексу типу Atlas Search з вказанням поля й параметрів векторного індексу у форматі JSON, збереження і підключення для подальшого пошуку.

## Пошук за найбільш схожим вектором

За допомогою агрегації та оператора **$vectorSearch** виконуємо векторний пошук у колекції, де є поле з векторними ембедингами. Запит шукає документи, вектори яких найбільш схожі на заданий вхідний вектор.

```js
const cursor = collection.aggregate([
  {
    $vectorSearch: {
      index: "назва_індексу", // Ім'я створеного векторного індексу
      queryVector: [/* вектор */], // Вектор-запит для порівняння
      path: "им'я_поля_з_вектором",  // Поле, де зберігаються ембедінги
      numCandidates: 100,  // Кількість кандидатів для приблизного пошуку
      limit: 10  // Максимальна кількість результатів
    }
  },
  {
    $project: {
      name: 1, // Вивід певних полів
      embedding: 1,
      score: { $meta: "vectorSearchScore" }  // Оцінка схожості документа до запиту
    }
  }
]);
```

* $vectorSearch - це оператор в агрегації, який виконує пошук найближчих векторів за заданим queryVector.

*  index вказує назву створеного векторного індексу, без якого запит не буде працювати.

* path - поле у документах, в якому збережені вектори для порівняння.

* numCandidates задає, скільки найближчих кандидатів спочатку розглянути, щоб оптимізувати пошук.

* limit обмежує кількість кінцевих результатів.

У стадії $project виводяться потрібні поля, зокрема поле score, яке отримується через $meta: "vectorSearchScore" — це спеціальна метаінформація з оцінкою схожості, яку можна використовувати для ранжування результатів.

Припустимо, результати пошуку за косинусною схожістю можуть виглядати так:

```json
[
  { "_id": 1, "name": "Документ A", "score": 0.95 },
  { "_id": 2, "name": "Документ B", "score": 0.89 }
]
```

Для векторного пошуку важливо враховувати тип відстані (косинусна, евклідова тощо).
