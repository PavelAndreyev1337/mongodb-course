# Лекція 3: CRUD-операції

CRUD-операції  - операції створення, читання, змінювання та видалення документів.

## Створення

Операції створення або вставки додають нові документи до колекції. Якщо колекція наразі не існує, операції вставки створять її.

MongoDB надає такі методи для вставки документів у колекцію:

* db.collection.insertOne() - додає один документ до колекції.
* db.collection.insertMany() - можна вставляти кілька документів у колекцію. Потрібно передати масив документів методу.

У наступному прикладі показано, як вставити новий документ до колекції **inventory**. Якщо в документі не вказано поле **_id**, MongoDB додасть поле **_id** зі значенням **ObjectId** до нового документа. 

```javascript
db.inventory.insertOne(
   { item: "canvas", qty: 100, tags: ["cotton"], size: { h: 28, w: 35.5, uom: "cm" } }
)
```

**insertOne()** повертає документ, який містить значення поля **_id** щойно вставленого документа.

У наступному прикладі до колекції **inventory** додаються три нові документи. Якщо в документах не вказано поле **_id**, MongoDB додає поле **_id** зі значенням **ObjectId** до кожного документа.

```javascript
db.inventory.insertMany([
   { item: "journal", qty: 25, tags: ["blank", "red"], size: { h: 14, w: 21, uom: "cm" } },
   { item: "mat", qty: 85, tags: ["gray"], size: { h: 27.9, w: 35.5, uom: "cm" } },
   { item: "mousepad", qty: 25, tags: ["gel", "blue"], size: { h: 19, w: 22.85, uom: "cm" } }
])
```

У MongoDB операції вставки спрямовані на одну колекцію. Усі операції запису в MongoDB є атомарними на рівні одного документа.

Щоб отримати вставлені документи, зробіть запит до колекції:

```javascript
db.inventory.find( {} )
```

Додаткові методи для вставок:

* db.collection.updateOne() при використанні з опцією **upsert: true**.

* db.collection.updateMany() при використанні з опцією **upsert: true**.

* db.collection.findAndModify() при використанні з опцією **upsert: true**.

* db.collection.findOneAndUpdate() при використанні з опцією **upsert: true**.

* db.collection.findOneAndReplace() при використанні з опцією **upsert: true**.

* db.collection.bulkWrite().

**Upsert** якщо значення **true**, виконує одну з наступних дій:
* Створює новий документ, якщо жоден документ не відповідає фільтру
* Оновлює окремий документ, який відповідає фільтру.
За замовчуванням встановлено значення **false**, що означає, що новий документ не вставляється, якщо збіг не знайдено.

## Читання

Операції читання витягують документи з колекції. Щоб запитувати документи, вкажіть предикат запиту, який вказує на документи, які потрібно повернути. Якщо вказати порожній предикат запиту **({ })**, запит поверне всі документи в колекції. MongoDB надає такі методи для читання документів з колекції:

* db.collection.find()

Щоб вибрати всі документи в колекції, передайте порожній документ як параметр фільтра запиту методу find. Параметр фільтра запиту визначає критерії вибору:

```javascript
db.inventory.find( {} )
```

Ця операція використовує предикат запиту **{}**, який відповідає наступному SQL-запиту:

```sql
SELECT * FROM inventory
```

Щоб указати умови рівності, використовуйте вирази `<field>:<value>` у документі фільтра запиту:

```javascript
{ <field1>: <value1>, ... }
```

У наступному прикладі з колекції inventory вибираються всі документи, статус яких дорівнює "D":

```javascript
db.inventory.find( { status: "D" } )
```

Ця операція використовує предикат запиту **{ status: "D" }**, який відповідає наступному SQL-запиту:

```sql
SELECT * FROM inventory WHERE status = "D"
```

Документ фільтра запитів може використовувати оператори запитів для визначення умов у такій формі:

```javascript
{ <field1>: { <operator1>: <value1> }, ... }
```

У наступному прикладі витягується з колекції inventory всі документи, статус яких дорівнює "A" або "D":

```javascript
db.inventory.find( { status: { $in: [ "A", "D" ] } } )
```

Операція використовує предикат запиту **{ status: { $in: [ "A", "D" ] } }**, який відповідає наступному SQL-запиту:

```sql
SELECT * FROM inventory WHERE status in ("A", "D")
```

Використовуючи оператор $or, можна вказати складений запит, щоб запит вибирав документи в колекції, що відповідають принаймні одній умові.
У наступному прикладі витягуються всі документи в колекції, статус яких дорівнює "A" або кількість менша за ($lt) 30:

```javascript
db.inventory.find( { $or: [ { status: "A" }, { qty: { $lt: 30 } } ] } )
```

Що відповідає наступному SQL-запиту:
```sql
SELECT * FROM inventory WHERE status = "A" OR qty < 30
```

У наступному прикладі складений запит document вибирає всі документи в колекції, статус яких дорівнює "A", а кількість (qty) менша за ($lt) 30, або елемент (item) починається з символу p:

```javascript
db.inventory.find( {
     status: "A",
     $or: [ { qty: { $lt: 30 } }, { item: /^p/ } ]
} )
```

Що відповідає наступному SQL-запиту:

```sql
SELECT * FROM inventory WHERE status = "A" AND ( qty < 30 OR item LIKE "p%")
```

Метод db.collection.find() повертає курсор до відповідних документів.
Курсор (cursor) — це об'єкт, який використовується для перебору результатів запиту до бази даних. MongoDB не повертає одразу всі документи, а повертає курсор — спеціальний об'єкт, який посторінково отримує документи.
Це дозволяє:

* ефективно працювати з великими наборами даних;
* уникати перевантаження пам’яті;
* обробляти дані поступово (наприклад, у циклі).

Наступні елементи також можуть читати документи з колекції: 
* Метод db.collection.findOne() 
* Етап конвеєра $match у конвеєрі агрегації. Етап конвеєра $match забезпечує доступ до запитів MongoDB.

Метод Collection.findOne() виконує ту саму операцію, що й метод Collection.find(), з обмеженням 1.

Створюємо колекцію інвентарю

```javascript
db.inventory.insertMany( [
   { item: "journal", qty: 25, size: { h: 14, w: 21, uom: "cm" }, status: "A" },
   { item: "notebook", qty: 50, size: { h: 8.5, w: 11, uom: "in" }, status: "A" },
   { item: "paper", qty: 100, size: { h: 8.5, w: 11, uom: "in" }, status: "D" },
   { item: "planner", qty: 75, size: { h: 22.85, w: 30, uom: "cm" }, status: "D" },
   { item: "postcard", qty: 45, size: { h: 10, w: 15.25, uom: "cm" }, status: "A" }
]);
```

Щоб указати умову запиту для полів у вбудованому/вкладеному документі, використовуйте крапкову нотацію **("field.nestedField")**.

У наступному прикладі вибираються всі документи, де поле uom, вкладене в поле розміру, дорівнює "in":

```javascript
db.inventory.find( { "size.uom": "in" } )
```

Документ фільтра запитів може використовувати оператори запитів для визначення умов у такій формі:

```javascript
db.inventory.find( { "size.h": { $lt: 15 }, "size.uom": "in", status: "D" } )
```

Щоб указати умову рівності для поля, яке є вбудованим/вкладеним документом, скористайтеся фільтром запиту document `{ <field>: <value> }, де <value>` – це документ, який потрібно зіставити.

Наприклад, наступний запит вибирає всі документи, де розмір поля дорівнює документу **{ h: 14, w: 21, uom: "cm" }**:

```javascript
db.inventory.find( { size: { h: 14, w: 21, uom: "cm" } } )
```

MongoDB не рекомендує порівняння вбудованих документів, оскільки операції вимагають точного збігу з вказаним `<value>` документом, включаючи порядок полів.
Наприклад, наступний запит не відповідає жодному документу в колекції:

```javascript
db.inventory.find(  { size: { w: 21, h: 14, uom: "cm" } }  )
```

```javascript
db.inventory.insertMany([
   { item: "journal", qty: 25, tags: ["blank", "red"], dim_cm: [ 14, 21 ] },
   { item: "notebook", qty: 50, tags: ["red", "blank"], dim_cm: [ 14, 21 ] },
   { item: "paper", qty: 100, tags: ["red", "blank", "plain"], dim_cm: [ 14, 21 ] },
   { item: "planner", qty: 75, tags: ["blank", "red"], dim_cm: [ 22.85, 30 ] },
   { item: "postcard", qty: 45, tags: ["blue"], dim_cm: [ 10, 15.25 ] }
]);
```

Щоб задати умову рівності для масиву, використовуйте запит document `{ <field>: <value> }, де <value>` – це точний масив, який потрібно знайти, включаючи порядок елементів.

Наведений нижче приклад запитів для всіх документів, де значенням тегів поля є масив із рівно двома елементами, "red" та "blank", у вказаному порядку:

```javascript
db.inventory.find( { tags: ["red", "blank"] } )
```

Якщо ж ви хочете знайти масив, який містить обидва елементи "red" та "blank", незалежно від порядку чи інших елементів у масиві, використовуйте оператор $all:

```javascript
db.inventory.find( { tags: { $all: ["red", "blank"] } } )
```

Наведений нижче приклад запитів для всіх документів, де tags – це масив, що містить рядок "red" як один з елементів:

```javascript
db.inventory.find( { tags: "red" } )
```

Запит до масиву зі складеними умовами фільтрації для елементів масиву. Наприклад, один елемент може задовольняти умову більше 15, а інший елемент може задовольняти умову менше 20, або один елемент може задовольняти обом умовам:

```javascript
db.inventory.find( { dim_cm: { $gt: 15, $lt: 20 } } 
```

Запит на елемент масиву, який відповідає кільком критеріям. Використовуйте оператор $elemMatch, щоб вказати кілька критеріїв для елементів масиву таким чином, щоб хоча б один елемент масиву відповідав усім заданим критеріям.
Наведено приклад запитів для документів, де масив dim_cm містить принаймні один елемент, який одночасно більший за ($gt) 22 та менший за ($lt) 30:

```javascript
db.inventory.find( { dim_cm: { $elemMatch: { $gt: 22, $lt: 30 } } } )
```

Використовуючи крапкову нотацію, можна вказати умови запиту для елемента за певним індексом або позицією масиву. Масив використовує індексацію, що починається з нуля.

```javascript
db.inventory.find( { "dim_cm.1": { $gt: 25 } } )
```

```javascript
db.inventory.insertMany( [
   { item: "journal", instock: [ { warehouse: "A", qty: 5 }, { warehouse: "C", qty: 15 } ] },
   { item: "notebook", instock: [ { warehouse: "C", qty: 5 } ] },
   { item: "paper", instock: [ { warehouse: "A", qty: 60 }, { warehouse: "B", qty: 15 } ] },
   { item: "planner", instock: [ { warehouse: "A", qty: 40 }, { warehouse: "B", qty: 5 } ] },
   { item: "postcard", instock: [ { warehouse: "B", qty: 15 }, { warehouse: "C", qty: 35 } ] }
]);
```

Використовуйте оператор $size для запиту масивів за кількістю елементів. Наприклад, наступний код вибирає документи, де теги масиву містять 3 елементи.

```javascript
db.inventory.find( { "tags": { $size: 3 } } )
```

Запит для документа, вкладеного в масив. У наступному прикладі вибираються всі документи, де елемент масиву instock відповідає вказаному документу:

```javascript
db.inventory.find( { "instock": { warehouse: "A", qty: 5 } } )
```

У наступному прикладі вибираються всі документи, де масив instock має принаймні один вбудований документ, що містить поле qty, значення якого менше або дорівнює 20.

```javascript
db.inventory.find( { 'instock.qty': { $lte: 20 } } )
```

У наступному прикладі вибираються всі документи, де масив instock має своїм першим елементом документ, що містить поле qty, значення якого менше або дорівнює 20:

```javascript
db.inventory.find( { 'instock.0.qty': { $lte: 20 } } )
```

Під час визначення умов для кількох полів, вкладених у масив документів, можна задати запит таким чином, щоб цим умовам відповідав або один документ, або будь-яка комбінація документів (включаючи один документ) у масиві відповідає умовам.
Наведено приклад запитів для документів, де масив instock має принаймні один вбудований документ, що містить як поле qty, що дорівнює 5, так і поле warehouse, що дорівнює **A**:

```javascript
db.inventory.find( { "instock": { $elemMatch: { qty: 5, warehouse: "A" } } } )
```

Якщо складені умови запиту для поля масиву не використовують оператор $elemMatch, запит вибирає ті документи, масив яких містить будь-яку комбінацію елементів, що задовольняє умови.
Наприклад, наступний запит знаходить документи, де будь-який документ, вкладений у масив instock, має поле qty більше 10, і будь-який документ (але не обов'язково той самий вбудований документ) у масиві має поле qty менше або рівне 20:

```javascript
db.inventory.find( { "instock.qty": { $gt: 10,  $lte: 20 } } )
```

Наведено приклад запитів для документів, де масив instock має принаймні один вбудований документ, що містить поле qty, що дорівнює 5, та принаймні один вбудований документ (але не обов'язково той самий вбудований документ) що містить польовий склад, що дорівнює **A**:

```javascript
db.inventory.find( { "instock.qty": 5, "instock.warehouse": "A" } )
```

Ви можете використовувати проекцію, щоб вибрати, які поля документа повернути із запиту.За замовчуванням запити в MongoDB повертають усі поля у відповідних документах. Щоб обмежити обсяг даних, які MongoDB надсилає до програм, можна включити проекційний документ, щоб указати або обмежити повернення полів.

```javascript
db.inventory.insertMany( [
  { item: "journal", status: "A", size: { h: 14, w: 21, uom: "cm" }, instock: [ { warehouse: "A", qty: 5 } ] },
  { item: "notebook", status: "A",  size: { h: 8.5, w: 11, uom: "in" }, instock: [ { warehouse: "C", qty: 5 } ] },
  { item: "paper", status: "D", size: { h: 8.5, w: 11, uom: "in" }, instock: [ { warehouse: "A", qty: 60 } ] },
  { item: "planner", status: "D", size: { h: 22.85, w: 30, uom: "cm" }, instock: [ { warehouse: "A", qty: 40 } ] },
  { item: "postcard", status: "A", size: { h: 10, w: 15.25, uom: "cm" }, instock: [ { warehouse: "B", qty: 15 }, { warehouse: "C", qty: 35 } ] }
]);
```

Проекція може явно включати кілька полів, встановивши для `<field>` значення 1 у документі проекції. Наведена нижче операція повертає всі документи, що відповідають запиту. У результуючому наборі повертаються лише поля item, status та, за замовчуванням, поля _id у відповідних документах.

```javascript
db.inventory.find( { status: "A" }, { item: 1, status: 1 } )
```

Операція відповідає наступному SQL-запиту:

```javascript
SELECT _id, item, status from inventory WHERE status = "A"
```

Наведений нижче приклад повертає всі поля, окрім полів «статус» та «наявність» у відповідних документах:

```javascript
db.inventory.find( { status: "A" }, { status: 0, instock: 0 } )
```

Ви можете повертати певні поля у вбудованому документі. Використовуйте крапкову нотацію для позначення вбудованого поля та встановіть значення 1 у документі проекції. Поле одиниці виміру залишається вбудованим у документ розміру:

```javascript
db.inventory.find(
   { status: "A" },
   { item: 1, status: 1, "size.uom": 1 }
)
```

Ви також можете вказати вбудовані поля за допомогою вкладеної форми. Наприклад, `{ item: 1, status: 1, size: { uom: 1 } }`.

Використовуйте крапкову нотацію для projection певних полів у документах, вбудованих у масив.

```javascript
db.inventory.find( { status: "A" }, { item: 1, status: 1, "instock.qty": 1 } )
```

The following example uses the $slice projection operator to return the last element in the instock array:

```javascript
db.inventory.find( { status: "A" }, { item: 1, status: 1, instock: { $slice: -1 } } )
```

Наприклад, ви не можете проектувати певні елементи масиву, використовуючи індекс масиву; наприклад, { "instock.0": 1 } проекція не проектує масив з першим елементом.

Коли ви використовуєте етап агрегації $project, він зазвичай має бути останнім етапом у вашому конвеєрі, що використовується для визначення полів, які потрібно повернути клієнту.

Ви можете запитувати порожні або відсутні поля в MongoDB.

```javascript
db.inventory.insertMany([
   { _id: 1, item: null },
   { _id: 2 }
])
```

Запит { item : null } знаходить документи, які містять поле item зі значенням null або не містять цього поля item:

```javascript
db.inventory.find( { item: null } )
```

Щоб запитувати поля, які існують і не є null, використовуйте фільтр { $ne : null }. Запит { item : { $ne : null } } знаходить документи, де поле item існує та має значення, відмінне від null:

```javascript
db.inventory.find( { item: { $ne : null } } )
```

Запит { item : { $type: 10 } } відповідає лише тим документам, які містять поле item, значення якого дорівнює null; тобто значення поля item має тип BSON Null (тип BSON 10):

```javascript
db.inventory.find( { item : { $type: 10 } } )
```

Запит { item : { $exists: false } } відповідає документам, які не містять поля item:

```javascript
db.inventory.find( { item : { $exists: false } } )
```

Ви можете вказати час очікування для завершення операцій читання. Якщо запит перевищує заданий час, MongoDB зупиняє запит, і запит не повертає жодних результатів. Щоб запобігти негативному впливу поточних запитів на продуктивність розгортання протягом тривалого часу, вкажіть відповідний час очікування запиту для вашої програми:


Параметр maxTimeMS дозволяє вказати час очікування запиту на рівні операції, тобто ви можете вказати різні часові обмеження для різних запитів. Наступний запит визначає обмеження часу в 50 мілісекунд:
```javascript
db.collection.find({description: '----'}).maxTimeMS(50)
```

Параметр кластера defaultMaxTimeMS визначає часовий ліміт за замовчуванням для виконання окремих операцій читання та застосовується до всіх запитів, які не містять параметра maxTimeMS():

Наступна команда встановлює тайм-аут запиту за замовчуванням на 5000 мілісекунд:

```javascript
db.runCommand( {
   setClusterParameter: {
      defaultMaxTimeMS: { readOperations: 5000 }
   }
} )
```

## Зміна (оновлення)

Операції оновлення змінюють існуючі документи в колекції. MongoDB надає такі методи для оновлення документів колекції:

* `db.collection.updateOne(<filter>, <update>, <options>)`
* `db.collection.updateMany(<filter>, <update>, <options>)`
* `db.collection.replaceOne(<filter>, <update>, <options>)`

У MongoDB операції оновлення спрямовані на одну колекцію. Усі операції запису в MongoDB є атомарними на рівні одного документа.

```javascript
db.inventory.insertMany( [
   { item: "canvas", qty: 100, size: { h: 28, w: 35.5, uom: "cm" }, status: "A" },
   { item: "journal", qty: 25, size: { h: 14, w: 21, uom: "cm" }, status: "A" },
   { item: "mat", qty: 85, size: { h: 27.9, w: 35.5, uom: "cm" }, status: "A" },
   { item: "mousepad", qty: 25, size: { h: 19, w: 22.85, uom: "cm" }, status: "P" },
   { item: "notebook", qty: 50, size: { h: 8.5, w: 11, uom: "in" }, status: "P" },
   { item: "paper", qty: 100, size: { h: 8.5, w: 11, uom: "in" }, status: "D" },
   { item: "planner", qty: 75, size: { h: 22.85, w: 30, uom: "cm" }, status: "D" },
   { item: "postcard", qty: 45, size: { h: 10, w: 15.25, uom: "cm" }, status: "A" },
   { item: "sketchbook", qty: 80, size: { h: 14, w: 21, uom: "cm" }, status: "A" },
   { item: "sketch pad", qty: 95, size: { h: 22.85, w: 30.5, uom: "cm" }, status: "A" }
] );
```

Для оновлення документа MongoDB надає оператори оновлення, такі як $set, для зміни значень полів. Щоб використовувати оператори оновлення, передайте методам оновлення документ оновлення такого вигляду:

```javascript
{
  <update operator>: { <field1>: <value1>, ... },
  <update operator>: { <field2>: <value2>, ... },
  ...
}
```

`$set`, створить поле, якщо воно не існує.

У наступному прикладі метод db.collection.updateOne() використовується для колекції inventory для оновлення першого документа, де item дорівнює "paper":

```javascript
db.inventory.updateOne(
   { item: "paper" },
   {
     $set: { "size.uom": "cm", status: "P" },
     $currentDate: { lastModified: true }
   }
)
```

* використовує оператор $set для оновлення значення поля size.uom до "cm" та значення поля status до "P",
* використовує оператор $currentDate для оновлення значення поля lastModified до поточної дати. Якщо поле lastModified не існує, $currentDate створить його. 


У наступному прикладі метод db.collection.updateMany() використовується для колекції інвентарю для оновлення всіх документів, кількість яких менша за 50:

```javascript
db.inventory.updateMany(
   { "qty": { $lt: 50 } },
   {
     $set: { "size.uom": "in", status: "P" },
     $currentDate: { lastModified: true }
   }
)
```


Під час заміни документа, документ-замінник повинен складатися лише з пар поле/значення. Документ-замінник не може містити вирази операторів оновлення. Документ-замінник може мати поля, що відрізняються від полів оригінального документа. У документі-заміннику можна пропустити поле _id, оскільки воно незмінне. Однак, якщо ви все ж таки включаєте поле _id, воно має мати те саме значення, що й поточне.
У наступному прикладі замінюється перший документ з колекції інвентарю, де елемент: "paper":

```javascript
db.inventory.replaceOne(
   { item: "paper" },
   { item: "paper", instock: [ { warehouse: "A", qty: 60 }, { warehouse: "B", qty: 40 } ] }
)
```

Ви можете використовувати позиційні оператори з мовою запитів MongoDB (MQL) для оновлення документів, що містять масиви, без заміни масиву або додавання до нього.


```javascript
db.employees.insertMany(
   [
      {
         _id: 'SF',
         engineering: [
            { name: 'Alice', email: 'missingEmail', salary: 100000 },
            { name: 'Bob', email: 'missingEmail', salary: 75000 }
         ],
         sales: [
            { name: 'Charlie', email: 'charlie@mail.com', salary: 90000, bonus: 1000 }
         ]
      },
      {
         _id: 'NYC',
         engineering: [
            { name: 'Dave', email: 'dave@mail.com', salary: 55000 },
         ],
         sales: [
            { name: 'Ed', email: 'ed@mail.com', salary: 99000, bonus: 2000 },
            { name: 'Fran', email: 'fran@mail.com', salary: 50000, bonus: 10000 }
         ]
      }
   ]
);
```

Щоб оновити лише перший збіг у масиві, використовуйте оператор $. Оператор $ діє як заповнювач для оновлення першого збігу елемента.

У наступному прикладі використовується метод updateOne() з операторами $ та $set для оновлення першої електронної адреси, яка має значення missingEmail в engineering  масиві, на alice@mail.com.

```javascript
db.employees.updateOne(
   { "engineering.email": "missingEmail" },
   { "$set": { "engineering.$.email": "alice@mail.com" } }
);
```

Використання оператора $ з $elemMatch для оновлення певного елемента, у наступному прикладі використовуються оператори $elemMatch та $ для оновлення електронної адреси Боба на "bob@mail.com":

```javascript
db.employees.updateOne(
   { engineering: { $elemMatch: { name: "Bob", email: "missingEmail" } } },
   { $set: { "engineering.$.email": "bob@mail.com" } }
);
```

Використання оператора `$[]` для оновлення всіх елементів масиву в документі. Розглянемо випадок, коли ви хочете надати додатковий бонус у розмірі 2000 доларів США своїм співробітникам відділу продажів. Ви можете використовувати метод updateMany() з оператором `$[]` та оператором $inc, щоб збільшити всі поля bonus в масиві продажів у документі на 2000:


```javascript
db.employees.updateMany(
   { "_id": "NYC" },
   { "$inc": { "sales.$[].bonus": 2000 } }
);
```

Використання оператора `$[<identifier>]` для оновлення елементів, що відповідають умові фільтра. Розглянемо випадок, коли вам потрібно оновити зарплати певних співробітників, якщо вони відповідають кільком умовам. Ви можете використати метод updateMany() з оператором `$[<identifier>]` для виконання цього завдання.

```javascript
db.employees.updateMany(
   {},
   {
      "$set": {
            "engineering.$[elemX].salary": 95000,
             "sales.$[elemY].salary": 75000
      }
   },
   {
      "arrayFilters": [
            { "elemX.name": "Bob", "elemX.salary": 75000 },
            { "elemY.name": "Ed", "elemY.salary": 50000, }
      ]
   }
);
```

elemX та elemY представляють два різні фільтри масиву: 
* Щоб відповідати elemX, об'єкт масиву повинен мати поле name Bob та salary 75000. 
* Щоб відповідати elemY, об'єкт масиву повинен мати поле name Ed та salary 50000.

Якщо елемент масиву в документі відповідає фільтру elemX, тоді updateMany() встановлює поле salary для об'єкта на 95000. Якщо елемент масиву відповідає фільтру elemY, тоді updateMany() встановлює поле salary для об'єкта на 75000.
Якщо фільтр не відповідає, відповідна операція $set не спрацьовує.

Ці оператори корисні під час роботи з масивами, оскільки вони позбавляють вас необхідності виконувати повну заміну масиву або розширені маніпуляції на стороні клієнта.


## Видалення

Операції видалення видаляють документи з колекції. MongoDB надає такі методи для видалення документів з колекції:
* db.collection.deleteOne()
* db.collection.deleteMany()

У MongoDB операції видалення спрямовані на одну колекцію. Усі операції запису в MongoDB є атомарними на рівні одного документа.

Ви можете вказати критерії або фільтри, які визначають документи для видалення. Ці фільтри використовують той самий синтаксис, що й операції читання.
Щоб видалити всі документи з колекції, передайте порожній фільтр document {} до методу db.collection.deleteMany():


```javascript
db.inventory.deleteMany({})
```

Ви можете вказати критерії або фільтри, які визначають документи для видалення. Фільтри використовують той самий синтаксис, що й операції читання.

У наступному прикладі видаляються всі документи з колекції інвентарю, у яких поле статусу дорівнює "A":

```javascript
db.inventory.deleteMany({ status : "A" })
```

У наступному прикладі видаляється перший документ зі статусом "D":

```javascript
db.inventory.deleteOne( { status: "D" } )
```

Операції видалення не скидають індекси, навіть якщо видаляються всі документи з колекції.

## Масовий запис

MongoDB надає клієнтам можливість виконувати операції запису масово.Починаючи з MongoDB 8.0, ви можете виконувати операції масового запису в кількох базах даних і колекціях. Якщо ви використовуєте версію, ранішу за MongoDB 8.0, ви можете виконувати операції масового запису в одній колекції. Щоб виконати операції масового запису в одній колекції, використовуйте метод mongosh db.collection.bulkWrite(). 
Ви можете налаштувати операції масового запису як упорядковані(ordered), так і неупорядковані(unordered). З упорядкованим списком операцій MongoDB виконує операції послідовно. Якщо під час обробки однієї з операцій запису виникає помилка, MongoDB повертає результат без обробки будь-яких інших операцій запису у списку. З невпорядкованим списком операцій MongoDB може виконувати операції паралельно, але така поведінка не гарантована. Якщо під час обробки однієї з операцій запису виникне помилка, MongoDB продовжить обробку решти операцій запису у списку.
За замовчуванням усі команди та методи масового запису виконують упорядковані операції. Щоб указати неупорядковані операції, встановіть для параметра ordered значення false під час виклику потрібної команди або методу.

Усі методи та команди масового запису підтримують такі операції запису: Insert One

* Update One

* Update Many

* Replace One

* Delete One

* Delete Many

У наступному прикладі db.collection.bulkWrite() виконується така операція з колекцією pizzas:

* Додає два документи за допомогою insertOne. 
* Оновлює документ за допомогою updateOne. 
* Видаляє документ за допомогою deleteOne. 
* Замінює документ за допомогою replaceOne.

```javascript
 db.pizzas.bulkWrite( [
  { insertOne: { document: { _id: 3, type: "beef", size: "medium", price: 6 } } },
  { insertOne: { document: { _id: 4, type: "sausage", size: "large", price: 10 } } },
  { updateOne: {
      filter: { type: "cheese" },
      update: { $set: { price: 8 } }
  } },
  { deleteOne: { filter: { type: "pepperoni"} } },
  { replaceOne: {
      filter: { type: "vegan" },
      replacement: { type: "tofu", size: "small", price: 4 }
  } }
])
```

У цьому прикладі Mongo.bulkWrite() виконує такі операції по порядку: 
* вставляє документ до колекції db.authors 
* вставляє документ до колекції db.books 
* оновлює попередній документ

```javascript
db.getMongo().bulkWrite(
   [
      {
         namespace: 'db.authors',
         name: 'insertOne',
         document: { name: 'Stephen King' }
      },
      {
         namespace: 'db.books',
         name: 'insertOne',
         document: { name: 'It' }
      },
      {
         namespace: 'db.books',
         name: 'updateOne',
         filter: { name: 'it' },
         update: { $set: { year: 1986 } }
      }
   ],
   {
      ordered: true,
   }
)
```


## Клієнтські бібліотеки

Ви можете підключити свою програму до MongoDB, використовуючи один з офіційних драйверів або похідну бібліотеку.

