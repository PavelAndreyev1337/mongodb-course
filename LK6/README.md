# Лекція 5: Часові ряди
Часові ряди — послідовність вимірювань чи подій, що відбуваються у фіксовані або неперервні часові проміжки. MongoDB пропонує спеціалізовані можливості для ефективного зберігання і аналізу таких даних через часові колекції (time series collections). Розглянемо:
- Моделювання даних часових рядів
 - Створення та налаштування часових колекцій
- Запити і агрегації зі складними прикладами
 - Оптимізація для великомасштабних даних і продуктивність
 - Практичні сценарії та кращі практики
## Основи: Що таке часові колекції в MongoDB?
MongoDB починаючи з версії 5.0 ввела нативну підтримку для часових серій через створення типу колекції, оптимізованої для записи і зберігання подій з часовою позначкою. В колекції є поле, за яким MongoDB сортує і індексує документи за часом (timeField). Додатково можна використовувати поле метаданих (metaField), яке містить константну інформацію про джерело або категорію даних. MongoDB групує записи в «баки» (buckets), які автоматично оптимізують сховище та швидкість доступу. Параметр granularity відповідає за очікуваний інтервал збору даних (секунди, хвилини або години), що оптимізує індексацію і стиснення.
Приклад створення колекції часових рядів:
```javascript
db.createCollection("sensorData", {
  timeseries: {
    timeField: "timestamp",
    metaField: "sensorId",
    granularity: "minutes"
  },
  expireAfterSeconds: 2592000 // TTL 30 днів
})
```
MongoDB автоматично створить індекси за sensorId та часом, покращуючи продуктивність запитів.
## Моделювання даних для часових рядів
Часові ряди в MongoDB мають дві основні частини в документі:
 - Поле часу (timestamp або інше, вказане в timeField) — момент, коли зняті дані
 - Поле метаданих (sensorId, deviceId) — постійна характеристика джерела даних
 - Дані метрики — змінні по часі, які збираються (температура, тиск, показники)
Важливо:
- Метадані не повинні часто змінюватися — це дозволяє MongoDB оптимізувати зберігання
- Зберігайте безпосередньо вимірювані параметри на «верхньому рівні» документа, щоб агрегації були простіше виконувати
## Вставка даних: як правильно працювати з часовими рядами
Сценарій типового вставлення — швидкий потік даних з пристроїв.
Приклад вставки:
```javascript
db.sensorData.insertMany([
  {
    timestamp: ISODate("2025-10-08T09:00:00Z"),
    sensorId: "A100",
    temperature: 22.5,
    humidity: 45
  },
  {
    timestamp: ISODate("2025-10-08T09:01:00Z"),
    sensorId: "A100",
    temperature: 22.7,
    humidity: 44
  }
])
```
MongoDB вміщує ці записи у внутрішні баки оптимізовано, забезпечуючи швидкий доступ і мінімальне використання пам’яті.

## Запит даних та агрегації: гнучкі інструменти для аналітики
MongoDB дозволяє писати запити, як у звичайних колекціях, фільтруючи за timestamp і metaField.
Фільтрація за часом та джерелом
```javascript
db.sensorData.find({
  sensorId: "A100",
  timestamp: { $gte: ISODate("2025-10-08T00:00:00Z"), $lt: ISODate("2025-10-09T00:00:00Z") }
})
```
Аналіз через агрегації
```javascript
db.sensorData.aggregate([
  { $match: { sensorId: "A100", timestamp: { $gte: ISODate("2025-10-08T00:00:00Z") } } },
  { $group: {
    _id: { hour: { $hour: "$timestamp" } },
    avgTemp: { $avg: "$temperature" },
    maxTemp: { $max: "$temperature" }
  }},
  { $sort: { "_id.hour": 1 } }
])
```

## Оптимізація продуктивності та використання ресурсів
### Індексація
- MongoDB автоматично створює індекси для timeField і metaField
- Додаткові індекси під специфічні поля метаданих підвищують швидкість фільтрації
- Складання складних індексів з часовим та метаданими для специфічних запитів (наприклад { "tags.symbol": 1, "time": -1 })
## Bucketing (упакування в баки)
- MongoDB організовує дані у баки всередині колекції, де кожен бак зберігає кілька записів за часовим інтервалом. Це скорочує загальну кількість документів, пришвидшує вставки та читання.
## Granularity (гранулярність)
- Правильно вказуйте granularity (seconds, minutes, hours) під ваші дані, щоб MongoDB автоматично оптимізував індекси та стиснення.
TTL (видалення старих даних)
- Якщо потрібно, вказуйте expireAfterSeconds для зберігання лише актуальних даних (наприклад, логів або моніторингових показників).

## Особливості MongoDB 8.0 для часових рядів
У MongoDB 8.0 покращена підтримка часових колекцій за рахунок нової технології запису в колонки зі стисненням, що знижує використання кешу та записів на диск.
Це дозволяє виконувати аналітику потужнішу і зменшує I/O, особливо для великих потоків даних.

## Приклад проєкту
Система моніторингу IoT-датчиків:
- Кожен датчик надсилає виміри температури, вологості, та інших параметрів кожні 30 секунд.
- Дані зберігаються в time series колекції з timeField: "timestamp" і metaField: "deviceID".
- Для звітності необхідно обчислювати добові, годинні макс/мін/середні показники.
- Виконуємо реальні запити для побудови графіків швидкості зміни температури, пошуку аномалій та агрегатів.

Створення колекції:
```javascript
db.createCollection("iotData", {
  timeseries: {
    timeField: "timestamp",
    metaField: "deviceID",
    granularity: "seconds"
  },
  expireAfterSeconds: 604800 // Зберігати дані 7 днів
})
```

Завантаження даних

```javascript
db.iotData.insertMany([
  { timestamp: ISODate("2025-10-08T08:30:00Z"), deviceID: "sensor01", temperature: 23.4, humidity: 50 },
  { timestamp: ISODate("2025-10-08T08:30:30Z"), deviceID: "sensor01", temperature: 23.5, humidity: 49 },
  // ... інші записи
])
```

Групування по годинах за середньою температурою:
```javascript
db.iotData.aggregate([
  { $match: { deviceID: "sensor01", timestamp: { $gte: ISODate("2025-10-08T00:00:00Z") } } },
  { $group: {
    _id: {
      hour: { $dateTrunc: { date: "$timestamp", unit: "hour" } }
    },
    avgTemp: { $avg: "$temperature" }
  }},
  { $sort: { "_id.hour": 1 } }
])
```

# Кращі практики
- Використовуйте нативні time series collections, а не саморобні схеми для зберігання часових рядів.
- Правильно вибирайте timeField та metaField.
- Комплектуйте індекси для оптимізації вибірок.
- Використовуйте granularity, щоб відповідати природі даних.
- Встановлюйте TTL, якщо потрібно автоматично видаляти застарілі дані.
