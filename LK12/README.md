# Тема 12: Моніторинг та оптимізація продуктивності
Продуктивність MongoDB залежить від багатьох факторів - налаштувань індексів, обсягу даних, складності запитів, конфігурації сервера та мережі. Моніторинг та своєчасна оптимізація допомагають підтримувати максимальну швидкість і надійність роботи.

## Основи моніторингу MongoDB
1\. Профілювання повільних запитів з виводом

Увімкнення профілювання займає час, але дає дані для аналізу:

```js
// Активуємо профілювання повільних запитів (>100 мс)
db.setProfilingLevel(2, {slowms: 100})

// Вивід 5 найповільніших запитів
db.system.profile.find({millis: {$gt: 100}}).sort({millis: -1}).limit(5).pretty()
```

Приклад виводу у консолі:

```json
{
  "op": "query",
  "ns": "test.collection",
  "millis": 325,
  "query": { "rating": "A" },
  "nreturned": 5,
  "planSummary": "IXSCAN { rating: 1 }"
}
```

Опис:

* **op**: тип операції - тут це query (запит);

* **ns**: простір імен (база.документи);

* **millis**: час виконання у мілісекундах (325 мс);

* **query**: умова запиту;

* **nreturned**: кількість документів, що повернулося;

* **planSummary**: опис плану виконання, наприклад, індексне сканування по полю rating (IXSCAN (індексне сканування) або ж COLLSCAN (повне сканування колекції) - MongoDB перебирає всі документи в колекції, що дуже повільно і неефективно для великих обсягів даних).

Цей вивід допомагає визначити повільні операції та наскільки ефективно використовується індексація.


2\. Аналіз плану виконання запиту (Explain)

План виконання допомагає зрозуміти, як MongoDB виконує запит, і чи оптимально він використовує індекси.

```js
var explainResult = db.collection.find({ rating: "A" }).explain("executionStats")

printjson(explainResult)
```

Приклад ключових частин виводу:

```json
{
  "queryPlanner": {
    "winningPlan": {
      "stage": "IXSCAN",
      "keyPattern": { "rating": 1 }
    }
  },
  "executionStats": {
    "nReturned": 15,
    "executionTimeMillis": 2,
    "totalKeysExamined": 15,
    "totalDocsExamined": 15
  }
}
```

Опис:

* **stage**: IXSCAN означає, що використовується індекс;

* **keyPattern**: індексоване поле;

* **nReturned**: кількість результатів;

* **executionTimeMillis**: час виконання (2 мс - дуже швидко);

* **totalKeysExamined** та **totalDocsExamined**: кількість перевірених індексних ключів і документів. Чим менші ці числа, тим ефективніше запит.

3\. Моніторинг ресурсів сервера
Команда serverStatus() повертає поточні метрики сервера.

```js
var status = db.serverStatus()

printjson({
  connections: status.connections,
  opcounters: status.opcounters,
  mem: status.mem,
  uptime: status.uptime
})
```

Приклад виводу:

```json
{
  "connections": {
    "current": 120,
    "available": 838,
    "totalCreated": 10500
  },
  "opcounters": {
    "insert": 12345,
    "query": 23456,
    "update": 6789,
    "delete": 1234
  },
  "mem": {
    "resident": 5120,
    "virtual": 10240,
    "mapped": 2048
  },
  "uptime": 86400
}
```

Опис:

* **connections.current**: поточна кількість відкритих з’єднань;

* **connections.available**: скільки з’єднань доступні для відкриття;

* **opcounters**: кількість операцій вставки, запитів, оновлень, видалень;

* **mem.resident**: використання пам’яті в МБ;

* **uptime**: час роботи сервера в секундах (тут - 24 години);

Ці показники дозволяють оцінити навантаження і виявити проблему у ресурсах або кількості клієнтських з’єднань.

## Підходи до оптимізації продуктивності
1\. Індексація.

Створення індексів значно покращує швидкість пошуку:

```js
// Створення індексу по одному полю
db.collection.createIndex({field1: 1})

// Складений індекс по двох полях
db.collection.createIndex({field1: 1, field2: -1})

// Перевірка існуючих індексів
db.collection.getIndexes()
```

Без індекса MongoDB сканує всі документи (COLLSCAN), що займає багато часу:

```js
db.collection.find({rating: "A"}).explain("executionStats")
```

Результат покаже велику кількість просканованих документів.

Після створення індекса:

```js
db.collection.createIndex({rating: 1})

db.collection.find({rating: "A"}).explain("executionStats")
```

Час виконання зменшиться, а кількість прочитаних документів знизиться пропорційно.

2\. Використання агрегатних операцій.

Потрібно використовувати агрегації для виконання складних обчислень на сервері, щоб зменшити обсяг даних, які повертаються:

```js
db.collection.aggregate([
  { $match: { status: "active" } },
  { $group: { _id: "$category", total: { $sum: "$amount" } } }
])
```

3\. Для оптимізації запитів, потрібно:
* уникати повних сканувань колекції;

* використовувати проєкції для вибірки тільки потрібних полів;

* пам’ятати про кешування результатів часто використовуваних запитів.
